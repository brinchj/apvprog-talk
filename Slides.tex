\documentclass{beamer}
\usepackage{amsmath}
\usepackage{listings}
\lstset{language=Haskell,basicstyle=\ttfamily}
%\usepackage{beamerthemesplit}
\usetheme{Szeged}

\title{Essence of Functional programming}
\subtitle{Part 2}
\author{Clara B. Behrmann \and Johan Brinch  \and  Frej Soya}
\date{\today}
\newcommand{\bind}{\texttt{>>=}}
\newcommand{\ret}{\texttt{return}}
\newcommand{\bs}{\texttt{\char`\\}}
\newcommand{\fs}{\char`/}
\newcommand{\at}{\texttt{a}}
\newcommand{\kt}{\texttt{k}}
\newcommand{\mt}{\texttt{k}}
\begin{document}

\begin{frame}
  \titlepage
\end{frame}


%\section*{Outline}
%\begin{frame}
%  \tableofcontents
%\end{frame}


\section{Monads Invariants}
%\subsection{The 3 Invariants}
\subsection{}
\frame{
 \frametitle{Monad Laws}
The monad laws consists of 3 invariants, that any monad must adhere to:
\begin{align*}
 &\ret\ \at~ & &\bind~\texttt{k}& &= \texttt{k a} && \text{(1: Left identity)} \\ 
 &\mt~ & &\bind\ \ret&  &= \texttt{m} && \text{(2: Right identity)}	 \\
\end{align*}
\begin{align*}
&&& \text{(3: Associativity)}  \\
  &&  &\mt\ \bind\ \textbf{(}\texttt{\bs a -> (k a) \bind\ (\bs b -> h b)}\textbf{)} \\
 &=& \textbf{(}&\mt\ \bind\ \texttt{(\bs a -> k a)}\textbf{)} \texttt{ \bind\ (\bs b -> h b)} \\
 % &ToDO && \text{3: Associativity} 
\end{align*}
}
%\subsection{Using the invariants}
\begin{frame}[fragile]
\frametitle{The Error Monad}
\begin{lstlisting}
data E = Suc a | Err String
Instance Monad E where
    return a       = Suc a     
    (Suc a) >>= k  = k a
    (Err s) >>= k  = Err s
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Left Identity}
\begin{lstlisting}
return a >>= k 
  = (Suc a) >>= k 
  = (\k (Suc a) -> k a) k (Suc a) 
  = k a
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Right Identity}
By case analysis on E: Suc a, Err s
\begin{lstlisting}
(Suc a) >>= return 
  = (Suc a) >>= (\a -> Suc a)
  = (\k (Suc a) -> k a) (\a -> Suc a) (Suc a)
  = (\a -> Suc a) a
  = Suc a
\end{lstlisting}
\begin{lstlisting}
(Err s) >>= return
  = (Err s) >>= (\a -> Suc a)
  = (\k (Err s) -> Err s) (\a -> Suc a) (Err s)
  = (Err s)
\end{lstlisting}
\end{frame}

%\begin{frame}[fragile]
%\frametitle{Associativity}

%\end{frame}

\begin{frame}[fragile]
\frametitle{Monad syntax sugar in haskell}
\begin{columns}[t]
  \begin{column}{5cm}
\begin{lstlisting}
do { x <- m0
   ; y <- m1
   ; return x+y
   }
\end{lstlisting}
  \end{column}
  \begin{column}{5cm}
\begin{lstlisting}
    m0 >>= \x ->    
    m1 >>= \y ->    
    return x+y
\end{lstlisting}
  \end{column}
\end{columns}



%1-3 slides of examples comparing bind/unit with do-syntax (transliteration)
\end{frame}
\begin{frame}[fragile]
\frametitle{How does them monad laws help me?}		
\textbf{Long Version:}
\vspace{-0.5cm}
\begin{columns}[t]
  \begin{column}{5cm}
\begin{lstlisting}
skip_and_get = 
  do { lineA <- read
     ; lineB <- read 
     ; return lineB 
     }
\end{lstlisting}
  \end{column}
  \begin{column}{5cm}
\begin{lstlisting}
skip_and_get =
  read >>= \lineA ->    
  read >>= \lineB ->    
  return lineB
\end{lstlisting}
  \end{column}
\end{columns}
\pause
\textbf{The right identity law provides this expected equivalence:} 
\vspace{-0.5cm}
\begin{columns}[t]
  \begin{column}{5cm}
\begin{lstlisting}
skip_and_get = 
  do { lineA <- read
     ; read
     }
\end{lstlisting}
  \end{column}
  \begin{column}{5cm}
\begin{lstlisting}
skip_and_get =
  read >>= \lineA ->    
  read
\end{lstlisting}
  \end{column}
\end{columns}
\end{frame}


\begin{frame}[fragile]
\frametitle{Monad syntax sugar in haskell}
\vspace{-0.5cm}
\begin{columns}[t]
  \begin{column}{5cm}
\begin{lstlisting}
do { y <- do { x <- m
             ; f x
             }
   ; g y 
   }
\end{lstlisting}
  \end{column}
  \begin{column}{5cm}
\begin{lstlisting}
(m >>= (\x -> f x)) 
   >>= (\y -> g y)
\end{lstlisting}
  \end{column}
\end{columns}

\pause

\begin{center}
\textbf{By Associativity}
\end{center}

\vspace{-0.5cm}
\begin{columns}[t]
  \begin{column}{5cm}
{\onslide<3->
\begin{lstlisting}
do { x <- m
   ; y <- f x
   ; g y 
   }
\end{lstlisting}
}
  \end{column}
  \begin{column}{5cm}
{\onslide<2->
\begin{lstlisting}
m >>= ((\x -> f x) 
  >>=  (\y -> g y))
\end{lstlisting}
}
  \end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Monad syntax sugar in haskell}
\vspace{-0.5cm}
\begin{columns}[t]
  \begin{column}{5cm}
\begin{lstlisting}
do { y <- do { x <- m
             ; f x
             }
   ; g y 
   }
\end{lstlisting}
  \end{column}
  \begin{column}{5cm}
\begin{lstlisting}
(m >>= (\x -> f x)) 
   >>= (\y -> g y)
\end{lstlisting}
  \end{column}
\end{columns}

\pause

\begin{center}
\textbf{By Associativity}
\end{center}

\vspace{-0.5cm}
\begin{columns}[t]
  \begin{column}{5cm}
{\onslide<3->
\begin{lstlisting}
do { x <- m
   ; y <- f x
   ; g y 
   }
\end{lstlisting}
}
  \end{column}
  \begin{column}{5cm}
{\onslide<2->
\begin{lstlisting}
m >>= ((\x -> f x) 
  >>=  (\y -> g y))
\end{lstlisting}
}
  \end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Monad syntax sugar in haskell}
\vspace{-0.5cm}

\begin{columns}[t]
  \begin{column}{5cm}
\begin{lstlisting}
do { x <- m 
   ; do { y <- f x 
        ; g y 
        }
   }
\end{lstlisting}
  \end{column}
  \begin{column}{5cm}
\begin{lstlisting}
m >>= ((\x -> f x) 
  >>=  (\y -> g y))
\end{lstlisting}
  \end{column}
\end{columns}

%1-3. How monads help the naive programmer. (Don't break normal expectations)
\end{frame}



%%\subsection{Monads and lists}
%\frame{
%\frametitle{For list monads}
%For the list monad together with the 3 invariants. The following invariants for Map and join apply.
%\begin{itemize}
%\item MapM 
%\item JoinM
%\item There are 7 extra invariants.
%\end{itemize}
%using the last one (8th) together with the 7 above, we can deduce the original 3 monad invariants 
%}

%\frame{
%\frametitle{Monads can generalise list comprehensions}
%Not that interesting?, Summary of another paper\\ 
%Basicly any list comprehension in haskell can be translated to a monad.  \\
%Thus list comphensions are syntactic sugar for some monads.
%}
\section{Continuations}
%\subsection{the CPS Intro}
\subsection{} 
\begin{frame}[fragile]
\frametitle{Continuation Passing Style}

\textbf{Continuation}\\
A continuation is a function representing the remainder of the program (to be continued). \\
Values are represented by functions that take such a continuation and return the final result. \\\ \\ 

\textbf{Monad of Continuations}
\begin{lstlisting}
type K a  = (a -> Answer) -> Answer

return :: a -> (a -> Answer) -> Answer
return a  = \c -> c a

m >>= k   = \c -> m (\a -> k a c)
\end{lstlisting}

%>>= :: ((a -> Answer) -> Answer) -> (a -> Answer) -> ((a -> Answer) -> Answer) 
 
 
%The continuation monad ``\texttt{K}'' \\
%Expressing continuations using monads. \\
%TODO: Write the K monad in bind and return form.\\
\end{frame}


%\frame{
%\frametitle{CPS interpreter} 
%\emph{kill this slide}\\  
%Creating a CPS intepreter using monads.
%But this time wadlers also ``simplifies''
%\begin{itemize}
%\item By removing each of occurrence of \bind 
%\item adding  ``bits'' to front to capture the continuation
%\item adding ``bits to the end pass the continuation
%\end{itemize}
% Each operation passes on the actual computation to the next function as a 'continuation'
%}

\begin{frame}[fragile]
\frametitle{Continuation Example?}

\lstset{basicstyle=\footnotesize\ttfamily}
\begin{lstlisting}
cplus :: ((a -> Answer) -> Answer) -> 
         ((a -> Answer) -> Answer) -> Answer
cplus a' b' = 
  \c -> c (a' (\a -> b' (\b -> a + b)))

n23 = \c -> c 23
n19 = \c -> c 19

\end{lstlisting}
\pause
\begin{lstlisting}
cplus n23 n19 
= \c -> c (n23          (\a -> n19 (\b ->  a + b))) 
= \c -> c ((\c -> c 23) (\a -> n19 (\b ->  a + b)))
= \c -> c (             (\a -> n19 (\b ->  a + b)) 23)
= \c -> c (                    n19 (\b -> 23 + b))
= \c -> c (           (\c -> c 19) (\b -> 23 + b))
= \c -> c (                        (\b -> 23 + b) 19)
= \c -> c (                               23 + 19)
= \c -> c                                 42
\end{lstlisting}
\lstset{language=Haskell}

%Example with add
%Instead of evaluating the actual ``add``. The ``add'' computations is passed on to the next expression the interpreter meets. \\
%This is done for all Terms, not just add.

\end{frame}




%\subsection{Monads can express CPS}
\begin{frame}[fragile]
\frametitle{The CPS Interpreter can act as a Monad Interpreter}

\begin{lstlisting}
type Answer = M Value

showK    :: K a -> String
showK n  =  showM (n unitM)

promoteK    :: M a -> K a
promoteK m  =  \c -> m >>= c
\end{lstlisting}


%By selecting the right type for \texttt{Answer}, the CPS interpreter can act as the original monad based interpreter. \\
%TODO: Write the definitions of PromoteK, ShowK\\
\end{frame}


\begin{frame}[fragile]
\frametitle{Preserves Modularity: Error Monad Example}

\begin{lstlisting}
errorK   :: String -> K a
errorK s =  promoteK (errorE s)
         =  \c -> (errorE s) >>= c
         =  \c -> (Err s) >>= c
         =  \c ->  Err s
\end{lstlisting}


%Wadler shows it's just as simple with the CPS style monad interpreter as using the monad interpreter. \\ 
%Examples with Error, State and Output monad. (Not that simple but anyhow).
\end{frame}


%\subsection{CPS can express Monads}
\begin{frame}[fragile]
\frametitle{Comparing CPS and Monads}
Wadler compares CPS and Monads
\begin{itemize}
\item CPS always provides escape facility
\item For monads it's a choice
\item We can fix this with expressing CPS as monads
\end{itemize}
\end{frame}



%\subsection{Call with current continuation}
\begin{frame}[fragile]
\frametitle{Call with current continuation}

\begin{lstlisting}
(callcc f)
\end{lstlisting}

\begin{itemize}
\item Call \texttt{f} with the current continuation wrapped in a
  function, \texttt{c}
\item When \texttt{f} calls \texttt{c} the program ``continues''
  execution from where \texttt{callcc} was originally called
\item The expression involving the \texttt{callcc} call returns the
  value passed to the continuation \texttt{c}
\end{itemize}


%\begin{itemize}
%\item Callcc takes the current continuation and creates a new Function 
%\item The function is saved in the enviroment
%\item Interprets the remaining expression with new enviroment
%\item Var extracts the continuation from the enviroment
%\item The Function is called with the ``4'' as argument
%\end{itemize}



\end{frame}


%\section{What's the gain\ldots}
%\subsection{I don't care about interpreters!}
%\subsection{}
\begin{frame}[fragile]
\frametitle{Applying this from a usage viewpoint}
\begin{itemize}
\item Web Frameworks
  \begin{enumerate}
  \item User wants to delete wiki page
  \item $\rightarrow$ ensure user is logged in 
  \item $\rightarrow$ get confirmation
  \item Delete page

  \end{enumerate}
\end{itemize}

\lstset{basicstyle=\footnotesize\ttfamily}
\begin{lstlisting}
(fun delete-page name)
 (unless (get-session-value 'user)
   (setf (get-session-value 'user) 
         (callcc 'wiki-login)))
 (callcc 'wiki-delete-confirm name)
 (delete-page-now name)
\end{lstlisting}
\small
\emph{Courtesy of Troels}

\end{frame}

%\subsection{Examples}
%\frame{
%\frametitle{Example A}
%A
% }
%\frame{
%\frametitle{Example B}
%B
% }
%\frame{
%\frametitle{Example C}
%C
% }

\begin{frame}[fragile]
\section{Conclusion}
\subsection{}
\begin{itemize}
\item Monads improves modularity
\item Continuations are simpler when wrapped away in Monads
\end{itemize}
\end{frame}

\end{document}
